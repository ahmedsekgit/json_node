{"version":3,"sources":["../src/JsonSearch.js"],"names":["RegExpEscape","string","replace","filterQueries","query","searchKeys","searchKeysToObjectKeyMap","tokens","containsTextRegex","filter","token","key","undefined","isNegate","map","q","join","notcontainsTextRegex","containsKeyRegexs","regex","RegExp","notContainsKeyRegexs","textSearch","textSearchNegate","keySearch","keySearchNegate","test","value","Array","isArray","find","item","JsonSearch","constructor","jsonArray","options","indice","length","Object","keys","setKeys","o","filterFunc","queryFuncs","itemMatched","keyFound","negatedKeywordNotFound","objectKey","entries"],"mappings":"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","sourcesContent":["/**\n * JsonSearch - https://www.npmjs.com/package/search-array\n * @license MIT\n */\nimport tokenizeQuery from './QueryTokenizer.js'\n\n/**\n * Escape regex special characters in srting\n * @param  {string} input string\n * @return {String} escpaed string\n */\nfunction RegExpEscape (string) {\n  return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n}\n\n/**\n * Escape regex special characters in srting\n * @param  {query} input search queries\n * @param  {searchKeys} Array of acceptable search keys\n * @param  {searchKeysToObjectKeyMap} map of searchKeys to object keys\n * @return {Object} regexes based on query and keys\n */\nfunction filterQueries (query, searchKeys, searchKeysToObjectKeyMap) {\n  const tokens = tokenizeQuery(query, searchKeys)\n\n  const containsTextRegex = tokens.filter(token => token.key === undefined && !token.isNegate).map(token => RegExpEscape(token.q)).join('|')\n  const notcontainsTextRegex = tokens.filter(token => token.key === undefined && token.isNegate).map(token => RegExpEscape(token.q)).join('|')\n  const containsKeyRegexs = tokens.filter(token => token.key !== undefined && !token.isNegate).map(token => { return { key: searchKeysToObjectKeyMap[token.key], regex: new RegExp(RegExpEscape(token.q), 'i') } })\n  const notContainsKeyRegexs = tokens.filter(token => token.key !== undefined && token.isNegate).map(token => { return { key: searchKeysToObjectKeyMap[token.key], regex: new RegExp(RegExpEscape(token.q), 'i') } })\n\n  return {\n    textSearch: containsTextRegex ? new RegExp(containsTextRegex, 'i') : undefined,\n    textSearchNegate: notcontainsTextRegex ? new RegExp(notcontainsTextRegex, 'i') : undefined,\n    keySearch: containsKeyRegexs,\n    keySearchNegate: notContainsKeyRegexs\n  }\n}\n\n/**\n * Test the value against the regex. It automatically detects type of value (Array or String) and performs apropriate test\n * @param  {value} String or Array to test the regex in\n * @param  {regex} RegExp to test with\n * @return {Boolean} True if regex matched the value\n */\nfunction test (value, regex) {\n  if (Array.isArray(value)) { return (value.find(item => regex.test(item)) !== undefined) } else { return regex.test(value) }\n}\n\nexport default class JsonSearch {\n  constructor (jsonArray, options = {}) {\n    this.jsonArray = jsonArray\n    this.indice = options.indice || {}\n    if (this.jsonArray.length <= 0) return\n    if (Object.keys(this.indice).length > 0) return\n    this.setKeys(jsonArray[0])\n  }\n\n  setKeys (item) {\n    for (const o in item) {\n      if (typeof item[o] === 'string') this.indice[o] = o\n      if (Array.isArray(item[o])) this.indice[o] = o\n    }\n  }\n\n  filterFunc (query) {\n    if (!query) return () => true\n\n    // search index keys\n    const searchKeys = Object.keys(this.indice)\n    const queryFuncs = filterQueries(query, searchKeys, this.indice)\n    return item => {\n      let itemMatched = true\n      let keyFound\n\n      let negatedKeywordNotFound = true\n      // here i have combined two separate for{} blocks for optimization purpose\n      // ideally, we should have a for{} block for testing normal search and\n      // another for{} block for negated search block (like what we have for indexed search)\n      // but I used different variables to do both searches in one for block\n      for (const [, objectKey] of Object.entries(this.indice)) {\n        const value = item[objectKey]\n\n        if (queryFuncs.textSearchNegate) {\n          negatedKeywordNotFound = negatedKeywordNotFound && !test(value, queryFuncs.textSearchNegate)\n        }\n        if (!negatedKeywordNotFound) return false\n\n        if (queryFuncs.textSearch) {\n          keyFound = keyFound || test(value, queryFuncs.textSearch)\n        }\n      }\n      if (keyFound === false) return false\n\n      // find indexed search\n      for (const { key, regex } of queryFuncs.keySearch) {\n        const value = item[key]\n        itemMatched = itemMatched && test(value, regex)\n        if (!itemMatched) return false\n      }\n      // find negated indexed search\n      for (const { key, regex } of queryFuncs.keySearchNegate) {\n        const value = item[key]\n        itemMatched = itemMatched && !test(value, regex)\n        if (!itemMatched) return false\n      }\n\n      return itemMatched\n    }\n  }\n\n  /**\n   * Search the jsonArray for the query and returns array of found objects\n   * @param  {q} query string\n   * @return {Array} array of found objects\n   */\n  query (q) {\n    return this.jsonArray.filter(this.filterFunc(q))\n  }\n}\n"],"file":"JsonSearch.js"}