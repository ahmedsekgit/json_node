"use strict";

exports.__esModule = true;

var _repeat = require("lodash/repeat");

var _repeat2 = _interopRequireDefault(_repeat);

var _last = require("lodash/last");

var _last2 = _interopRequireDefault(_last);

var _get = require("lodash/get");

var _get2 = _interopRequireDefault(_get);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var INDENT_TYPE_TOP_LEVEL = "top-level";
var INDENT_TYPE_BLOCK_LEVEL = "block-level";
var INDENT_TYPE_CASE_LEVEL = 'case-level';

/**
 * Manages indentation levels.
 *
 * There are two types of indentation levels:
 *
 * - BLOCK_LEVEL : increased by open-parenthesis
 * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
 */

var Indentation = function () {
    /**
     * @param {String} indent Indent value, default is "  " (2 spaces)
     */
    function Indentation(indent) {
        _classCallCheck(this, Indentation);

        this.indent = indent || "  ";
        this.indentTypes = [];
        /** 存储因为Block换行，重新计算offset时，暂存旧值，用于清除block影响时恢复 */
        this.IndentStack = [];

        /** 记录最大影响因子，与当前置顶词的差值，确保对齐方式 */
        this.diffTLIndent = 0;
        /** 因为第一个词未换行,所以不需要加上置顶词的长度 */
        this.SkipTopLevelEffectIndent = false;

        /** 记录当前顶级换行token带来的空格数影响 */
        this.offset = 0;

        /** case 语句的默认缩进 */
        this.caseIndent = 8;

        /** 是否要上下对齐 */
        this.useStandardMode = false;
    }

    Indentation.prototype.changeIndentMode = function changeIndentMode(standardMode) {
        this.useStandardMode = standardMode;
    };

    Indentation.prototype.markoffset = function markoffset() {
        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

        // 记录最大值，保证对齐效果一致
        this.offset = Math.max(this.offset, token.length, 6);
    };

    Indentation.prototype.markDiffIndent = function markDiffIndent() {
        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

        this.diffTLIndent = this.offset - token.length;
    };

    /** return Indent with 2 multiples*/


    Indentation.prototype.prettyIndent = function prettyIndent() {
        var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        var length = text.length;
        if (length === 0) {
            return text;
        }
        return text.length % 2 ? text + ' ' : text;
    };

    /**
     * Returns current indentation string.
     * @return {String}
     */


    Indentation.prototype.getIndent = function getIndent() {
        if (!this.useStandardMode) {
            return (0, _repeat2["default"])(this.indent, this.indentTypes.length);
        }
        var lastItem = this.IndentStack.slice(-1)[0];
        var additionalIndent = (0, _get2["default"])(lastItem, 'additionalIndent', 0);
        // indentTypes只有两个类型 type = Array<INDENT_TYPE_TOP_LEVEL | INDENT_TYPE_BLOCK_LEVEL>
        if ((0, _last2["default"])(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            // 非第一个关键词，需要换行缩进展示
            if (!this.SkipTopLevelEffectIndent) {
                additionalIndent += this.offset;
            } else {
                // topLevel词汇第一个影响token，只需要增加对应的空格，上下对齐即可
                var final = this.indent + (0, _repeat2["default"])(" ", this.diffTLIndent);
                return final;
            }
        }
        return (0, _repeat2["default"])(this.indent, this.indentTypes.length) + this.prettyIndent((0, _repeat2["default"])(" ", additionalIndent));
    };

    /**
     * return Indent at first line of a condition statement.
     */


    Indentation.prototype.getFirstCaseIndent = function getFirstCaseIndent(casevalue) {
        // 1 is the comma length
        return (0, _repeat2["default"])(" ", this.caseIndent - casevalue.length + 1);
    };

    Indentation.prototype.setSkipTopLevelEffectIndent = function setSkipTopLevelEffectIndent(value) {
        this.SkipTopLevelEffectIndent = value;
    };

    /**
     * Increases indentation by one top-level indent.
     */


    Indentation.prototype.increaseToplevel = function increaseToplevel() {
        var token = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";

        this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
        // mark top-level defaults to 6
        this.markoffset(token);
        // mark diff length
        this.markDiffIndent(token);
        // forbidden top-level token effect next token
        this.setSkipTopLevelEffectIndent(true);
    };

    /**
     * Increases indentation by one block-level indent.
     * 如果是子查询，则增加额外的空格，保证对齐风格
     * 普通函数如下：
     * count(
     *   XXXXXXXXXX
     * )
     * 子查询如下：
     * from  (
     *          select XX
     *          from   XX
     *       )
     */


    Indentation.prototype.increaseBlockLevel = function increaseBlockLevel(blockLevelDefaultIndent, isSubquery) {
        this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
        var blockIndent = blockLevelDefaultIndent - (this.indentTypes.length - 1) * 2;
        // 进入子查询，全部都恢复默认
        this.storeOffset(blockIndent);
        this.offset = 0;
    };

    /**
     * Increase indentation by one case-level indent.
     * Add caseIndent in case statement.
     */


    Indentation.prototype.increaseCaseLevel = function increaseCaseLevel(caseLevelDefaultIndent) {
        this.indentTypes.push(INDENT_TYPE_CASE_LEVEL);

        // 进入case when作用域，全部都恢复默认
        var caseIndent = caseLevelDefaultIndent - (this.indentTypes.length - 1) * 2;
        this.storeOffset(caseIndent);
        this.offset = 0;
    };

    /**
     * Decreases indentation by one top-level indent.
     * Does nothing when the previous indent is not top-level.
     */


    Indentation.prototype.decreaseTopLevel = function decreaseTopLevel() {
        if ((0, _last2["default"])(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            this.indentTypes.pop();
            this.offset = 0;
        }
    };

    /**
     * Decreases indentation by one block-level indent.
     * If there are top-level indents within the block-level indent,
     * throws away these as well.
     */


    Indentation.prototype.decreaseBlockLevel = function decreaseBlockLevel() {
        while (this.indentTypes.length > 0) {
            var type = this.indentTypes.pop();
            if (type === INDENT_TYPE_BLOCK_LEVEL) {
                this.recovertOffset();
                break;
            }
        }
    };

    /**
     * Decrease indentation by one case-level indent.
     */


    Indentation.prototype.decreaseCaseLevel = function decreaseCaseLevel() {
        while (this.indentTypes.length > 0) {
            var type = this.indentTypes.pop();
            if (type === INDENT_TYPE_CASE_LEVEL) {
                this.recovertOffset();
                break;
            }
        }
    };

    /**
     * 保存父查询的偏移量，进入子作用域
     */


    Indentation.prototype.storeOffset = function storeOffset(indent) {
        this.IndentStack.push({
            additionalIndent: indent,
            offset: this.offset
        });
    };

    /**
     * 子作用域结束时，恢复父查询的偏移量
     */


    Indentation.prototype.recovertOffset = function recovertOffset() {
        var item = this.IndentStack.pop();
        this.offset = (0, _get2["default"])(item, 'offset', 0);
    };

    return Indentation;
}();

exports["default"] = Indentation;
module.exports = exports["default"];