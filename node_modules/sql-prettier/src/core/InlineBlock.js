import tokenTypes from "./tokenTypes";
import trimEnd from "lodash/trimEnd";

const INLINE_MAX_LENGTH = 50;
const NEW_LINE_REG = /\r?\n/;

/**
 * Bookkeeper for inline blocks.
 *
 * Inline blocks are parenthized expressions that are shorter than INLINE_MAX_LENGTH.
 * These blocks are formatted on a single line, unlike longer parenthized
 * expressions where open-parenthesis causes newline and increase of indentation.
 */
export default class InlineBlock {
    constructor() {
        this.level = 0;
    }

    /**
     * Begins inline block when lookahead through upcoming tokens determines
     * that the block would be smaller than INLINE_MAX_LENGTH.
     * @param  {Object[]} tokens Array of all tokens
     * @param  {Number} index Current token position
     */
    beginIfPossible(tokens, index) {
        if (this.level === 0 && this.isInlineBlock(tokens, index)) {
            this.level = 1;
        }
        else if (this.level > 0) {
            this.level++;
        }
        else {
            this.level = 0;
        }
    }

    /**
     * Finishes current inline block.
     * There might be several nested ones.
     */
    end() {
        this.level--;
    }

    /**
     * True when inside an inline block
     * @return {Boolean}
     */
    isActive() {
        return this.level > 0;
    }

    // Check if this should be an inline parentheses block
    // Examples are "NOW()", "COUNT(*)", "int(10)", key(`somecolumn`), DECIMAL(7,2)
    // true表示不换行
    isInlineBlock(tokens, index) {
        let length = 0;
        let level = 0;

        if(this.isSubQuery(tokens, index)) {
            return false;
        }

        for (let i = index; i < tokens.length; i++) {
            const token = tokens[i];
            length += trimEnd(token.value).length;

            // Overran max length or has Enter in block sql
            if (length > INLINE_MAX_LENGTH || NEW_LINE_REG.test(token.value)) {
                return false;
            }

            if (token.type === tokenTypes.OPEN_PAREN) {
                level++;
            }
            else if (token.type === tokenTypes.CLOSE_PAREN) {
                level--;
                if (level === 0) {
                    return true;
                }
            }

            if (this.isForbiddenToken(token)) {
                return false;
            }
        }
        return false;
    }


    /** 原先通过括号内长度来判断是否换行。但是在函数计算中，会显得很乱。此处改成仅子查询换行，非子查询则不换行 */
    isSubQuery(tokens, index) {
        let i = index - 1;
        let wordBeforeBracket = tokens[i];
        // 避免无聊的用括号一直包。。导致不想要的格式化异常
        while(wordBeforeBracket && [tokenTypes.OPEN_PAREN, tokenTypes.WHITESPACE].includes(wordBeforeBracket.type)){
            i = i - 1;
            wordBeforeBracket = tokens[i];
        }
        // 此处用，括号前面的有效关键词，是否为from。来判断是否是子查询。不是子查询则inlineBlock为true
        return String(wordBeforeBracket.value).toLowerCase() === 'from';
    }


    // Reserved words that cause newlines, comments and semicolons
    // are not allowed inside inline parentheses block
    isForbiddenToken({type, value}) {
        return value === "SELECT" ||
            type === tokenTypes.RESERVED_TOPLEVEL ||
            // type === tokenTypes.RESERVED_NEWLINE ||
            type === tokenTypes.COMMENT ||
            type === tokenTypes.BLOCK_COMMENT ||
            value === ";";
    }
}
