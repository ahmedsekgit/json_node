import repeat from "lodash/repeat";
import last from "lodash/last";
import get from "lodash/get";

const INDENT_TYPE_TOP_LEVEL = "top-level";
const INDENT_TYPE_BLOCK_LEVEL = "block-level";
const INDENT_TYPE_CASE_LEVEL = 'case-level';

/**
 * Manages indentation levels.
 *
 * There are two types of indentation levels:
 *
 * - BLOCK_LEVEL : increased by open-parenthesis
 * - TOP_LEVEL : increased by RESERVED_TOPLEVEL words
 */
export default class Indentation {
    /**
     * @param {String} indent Indent value, default is "  " (2 spaces)
     */
    constructor(indent) {
        this.indent = indent || "  ";
        this.indentTypes = [];
        /** 存储因为Block换行，重新计算offset时，暂存旧值，用于清除block影响时恢复 */
        this.IndentStack = [];
        
        /** 记录最大影响因子，与当前置顶词的差值，确保对齐方式 */
        this.diffTLIndent = 0;
        /** 因为第一个词未换行,所以不需要加上置顶词的长度 */
        this.SkipTopLevelEffectIndent = false;

        /** 记录当前顶级换行token带来的空格数影响 */
        this.offset = 0;

        /** case 语句的默认缩进 */
        this.caseIndent = 8;

        /** 是否要上下对齐 */
        this.useStandardMode = false;
    }

    changeIndentMode(standardMode) {
        this.useStandardMode = standardMode;
    }

    markoffset(token = "") {
        // 记录最大值，保证对齐效果一致
        this.offset = Math.max(
            this.offset, 
            token.length,
            6
        );
    }

    markDiffIndent(token = "") {
        this.diffTLIndent = this.offset - token.length
    }

    /** return Indent with 2 multiples*/
    prettyIndent(text = '') {
        const length = text.length;
        if(length === 0) {
          return text
        }
        return text.length % 2 ? text + ' ' : text
    }

    /**
     * Returns current indentation string.
     * @return {String}
     */
    getIndent() {
        if(!this.useStandardMode) {
            return repeat(this.indent, this.indentTypes.length); 
        }
        const lastItem = this.IndentStack.slice(-1)[0];
        let additionalIndent = get(lastItem, 'additionalIndent', 0);
        // indentTypes只有两个类型 type = Array<INDENT_TYPE_TOP_LEVEL | INDENT_TYPE_BLOCK_LEVEL>
        if(last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            // 非第一个关键词，需要换行缩进展示
            if(!this.SkipTopLevelEffectIndent) {
                additionalIndent += this.offset
            }else {
                // topLevel词汇第一个影响token，只需要增加对应的空格，上下对齐即可
                const final = this.indent + repeat(" ", this.diffTLIndent);
                return final
            }
        }
        return repeat(this.indent, this.indentTypes.length) + this.prettyIndent(repeat(" ", additionalIndent));
    }

    /**
     * return Indent at first line of a condition statement.
     */
    getFirstCaseIndent(casevalue) {
        // 1 is the comma length
        return repeat(" ", this.caseIndent - casevalue.length + 1);
    }

    setSkipTopLevelEffectIndent(value) {
        this.SkipTopLevelEffectIndent = value;
    }

    /**
     * Increases indentation by one top-level indent.
     */
    increaseToplevel(token = "") {
        this.indentTypes.push(INDENT_TYPE_TOP_LEVEL);
        // mark top-level defaults to 6
        this.markoffset(token);
        // mark diff length
        this.markDiffIndent(token);
        // forbidden top-level token effect next token
        this.setSkipTopLevelEffectIndent(true);
    }

    /**
     * Increases indentation by one block-level indent.
     * 如果是子查询，则增加额外的空格，保证对齐风格
     * 普通函数如下：
     * count(
     *   XXXXXXXXXX
     * )
     * 子查询如下：
     * from  (
     *          select XX
     *          from   XX
     *       )
     */
    increaseBlockLevel(blockLevelDefaultIndent, isSubquery) {
        this.indentTypes.push(INDENT_TYPE_BLOCK_LEVEL);
        const blockIndent = blockLevelDefaultIndent - (this.indentTypes.length - 1) * 2;
        // 进入子查询，全部都恢复默认
        this.storeOffset(blockIndent);
        this.offset = 0;  
    }

    /**
     * Increase indentation by one case-level indent.
     * Add caseIndent in case statement.
     */
    increaseCaseLevel(caseLevelDefaultIndent) {
        this.indentTypes.push(INDENT_TYPE_CASE_LEVEL);

        // 进入case when作用域，全部都恢复默认
        const caseIndent = caseLevelDefaultIndent - (this.indentTypes.length - 1) * 2;
        this.storeOffset(caseIndent);
        this.offset = 0;
    }

    /**
     * Decreases indentation by one top-level indent.
     * Does nothing when the previous indent is not top-level.
     */
    decreaseTopLevel() {
        if (last(this.indentTypes) === INDENT_TYPE_TOP_LEVEL) {
            this.indentTypes.pop();
            this.offset = 0;
        }
    }

    /**
     * Decreases indentation by one block-level indent.
     * If there are top-level indents within the block-level indent,
     * throws away these as well.
     */
    decreaseBlockLevel() {
        while (this.indentTypes.length > 0) {
            const type = this.indentTypes.pop();
            if (type === INDENT_TYPE_BLOCK_LEVEL) {
                this.recovertOffset();
                break;
            }
        }
    }

    /**
     * Decrease indentation by one case-level indent.
     */
    decreaseCaseLevel() {
        while (this.indentTypes.length > 0) {
            const type = this.indentTypes.pop();
            if (type === INDENT_TYPE_CASE_LEVEL) {
                this.recovertOffset()
                break;
            }
        }
    }

    /**
     * 保存父查询的偏移量，进入子作用域
     */
    storeOffset(indent) {
        this.IndentStack.push({
            additionalIndent: indent,
            offset: this.offset
        });
    }


    /**
     * 子作用域结束时，恢复父查询的偏移量
     */
    recovertOffset() {
        const item = this.IndentStack.pop();
        this.offset = get(item, 'offset', 0);
    }
}
